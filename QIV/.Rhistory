SL.list = SL.hpara$SLL,           # Machine learning algorithms
MTRY = SL.hpara$MTRY,
MLPL = SL.hpara$MLPL,
NMN = SL.hpara$NMN,
MLPdecay = SL.hpara$MLPdecay)
nuissance_X = function(X){
pi_1 = predict(model_a_z, data.frame(X,z=1))[[1]]
pi_0 = predict(model_a_z, data.frame(X,z=0))[[1]]
Ey_a1z1 = predict(model_y_za, data.frame(X,z=1,a=1))[[1]]
phi_0 = predict(model_y_za, data.frame(X,z=0,a=1))[[1]]
phi_1 = Ey_a1z1-phi_0
Ey_z1 = predict(model_y_z, data.frame(X,z=1))[[1]]
Ey_z0 = predict(model_y_z, data.frame(X,z=0))[[1]]
psi = (Ey_z1 - Ey_z0-phi_1)/(pi_1-pi_0)
return(data.frame(psi,phi_1,phi_0,pi_1,pi_0))
}
nuis = nuissance_X(data_pred[,1:2])
phi_1 = nuis$phi_1
phi_0 = nuis$phi_0
psi = nuis$psi
pi_1 = nuis$pi_1
pi_0 = nuis$pi_0
#for EIF
z = data_pred[[4]]
a = data_pred[[5]]
# model this later
pz_x = z*0.5 + (1-z)*0.5
pa_x = pi_1*pz_x + pi_0*(1-pz_x)
pa_zx = predict(model_a_z, data.frame(data_pred[,c(1:2,4)]))[[1]]
paz_x = a*pa_zx*pz_x + (1-a)*(1-pa_zx)*pz_x
y_L = predict(model_y, data.frame(data_pred[,1:2]))[[1]]
p_Y_0 = y_L - a*psi - z*phi_1
df_ = data.frame(pi_1,
pi_0,
phi_1,
phi_0,
psi,
p_Y_0,
pz_x,
pa_x,
paz_x)
return(cbind(data_pred,df_))
}
generated = single_gen_QIV(500)
data_input = generated[[1]]
generated = single_gen_QIV(500)
data_input = generated[[1]]
single_gen_QIV = function(n){
###
# Simulation Parameters 10/10
# p_z = 0.5
# pi_1 = 0.75
# pi_0 = 0.25
# phi_1 = 1
# psi = 4
###
# Covariates:
x1 <- runif(n,0,1)
x2 <- rnorm(n,0,2)
x <- cbind(x1,x2)
u <- rnorm(n,0,1)
### Correlated
# ux <- MASS::mvrnorm(n, mu = c(0,0), Sigma = matrix(c(1,0.5,0.5,1),2,2))
###
# IV:
# Restriction: Independence from U
p_z = 0.5
z <- rbinom(n,1,prob = p_z)
# Treatment:
ps <- function(z,u){
p_0 <- 0.25
alpha_z <- log(3)
alpha_u <-function(u){0.1*(u>0)}
return(p_0*exp(alpha_z*z + alpha_u(u)))
}
ps_ = ps(z,u)
a <- rbinom(n,1,ps_);
print(cbind(a,z,ps_*p_z))
# Outcome
# Restrictions: Exclusion restriction and no A,U interaction.
p_2 <- function(Z,U,A,X){
#beta_a <- function(u){1*(u>0)}
beta_a <- function(u){4}
beta_u <- function(u){0.5*u}
beta_z <- 1
beta_x = as.matrix(c(1,-1),nrow=2)
return(beta_a(U)*A + beta_u(U) + beta_z*Z + X%*%beta_x)
}
error <- rnorm(n,sd=0.2)
y <- p_2(Z=z,U=u,A=a,X=x) + error
test_6_1 <- mean(p_2(Z=1,U=u,A=1,X=x)-p_2(Z=1,U=u,A=0,X=x)) ==
mean(p_2(Z=0,U=u,A=1,X=x)-p_2(Z=0,U=u,A=0,X=x))
u_s <- rnorm(n,0,1)
test_6_2 <- mean(p_2(Z=1,U=u_s,A=1,X=x)-p_2(Z=1,U=u_s,A=0,X=x)) ==
mean(p_2(Z=1,U=u,  A=1,X=x)-p_2(Z=1,U=u,  A=0,X=x))
test_6_3 <- mean(p_2(Z=0,U=u_s,A=1,X=x)-p_2(Z=0,U=u_s,A=0,X=x)) ==
mean(p_2(Z=0,U=u,  A=1,X=x)-p_2(Z=0,U=u,  A=0,X=x))
if(!(test_6_1&test_6_2&test_6_3)){
stop("assumptions violated!")
}
mu1z <- p_2(Z=z,U=u,A=rep(1,n),X=x) + error
mu0z <- p_2(Z=z,U=u,A=rep(0,n),X=x) + error
ATT <-  sum(a*mu1z-a*mu0z)/sum(a)
df <- data.frame(x1,x2,y,z,a)
return(list(data = df, att = ATT))
}
##models
# Order of covariates MUST be (x1,x2,y,z,a,s)
my_SL_QIV = function(data_train, data_pred, choice = c(1,7)){
SL.hpara <- list()
SL.hpara$SLL <- choice
# Superlearner basic learning algorithms:
# 1: GLM
# 2: lasso/ridge
# 3: earth
# 4: GAM
# 5: xgboost
# 6: polynomial spline
# 7: random forest
# 9: gbm
# 10: 1-layer MLP
SL.hpara$MLPL <- c(1)
SL.hpara$MTRY <- c(1)
SL.hpara$NMN <- 50
SL.hpara$MLPdecay <- 10^c(-1,-3)
# data_train: (1:x1,2:x2,3:y,4:z,5:a,s)
# Model of E(Z|X)
# model_z = MySL(Data = data_train,                # training dataset
#                locY = 4,                         # response variable Z = column 4
#                locX = c(1,2),                    # explanatory variable X1,X2
#                Ydist = binomial(),               # Z is binary
#                SL.list = SL.hpara$SLL,           # Machine learning algorithms
#                MTRY = SL.hpara$MTRY,
#                MLPL = SL.hpara$MLPL,
#                NMN = SL.hpara$NMN,
#                MLPdecay = SL.hpara$MLPdecay)
#
#
# Model of E(A|Z,X)
model_a_z = MySL(Data = data_train,              # training dataset
locY = 5,                         # response variable A = column 5
locX = c(1,2,4),                  # explanatory variable X1,X2,Z
Ydist = binomial(),               # A is binary
SL.list = SL.hpara$SLL,           # Machine learning algorithms
MTRY = SL.hpara$MTRY,
MLPL = SL.hpara$MLPL,
NMN = SL.hpara$NMN,
MLPdecay = SL.hpara$MLPdecay)
# Model of E(A|X)
# model_a_x = MySL(Data = data_train,              # training dataset
#                locY = 5,                         # response variable A = column 5
#                locX = c(1,2),                    # explanatory variable X1,X2
#                Ydist = binomial(),               # A is binary
#                SL.list = SL.hpara$SLL,           # Machine learning algorithms
#                MTRY = SL.hpara$MTRY,
#                MLPL = SL.hpara$MLPL,
#                NMN = SL.hpara$NMN,
#                MLPdecay = SL.hpara$MLPdecay)
# Model of E(Y|Z,A,X)
model_y_za = MySL(Data = data_train,             # training dataset
locY = 3,                         # response variable Y = column 3
locX = c(1,2,4,5),                # explanatory variable X1,X2,Z,A
Ydist = gaussian(),               # Y is continuous
SL.list = SL.hpara$SLL,           # Machine learning algorithms
MTRY = SL.hpara$MTRY,
MLPL = SL.hpara$MLPL,
NMN = SL.hpara$NMN,
MLPdecay = SL.hpara$MLPdecay)
# Model of E(Y|Z,X)
model_y_z =  MySL(Data = data_train,             # training dataset
locY = 3,                         # response variable Y = column 3
locX = c(1,2,4),                # explanatory variable X1,X2,Z
Ydist = gaussian(),               # Y is continuous
SL.list = SL.hpara$SLL,           # Machine learning algorithms
MTRY = SL.hpara$MTRY,
MLPL = SL.hpara$MLPL,
NMN = SL.hpara$NMN,
MLPdecay = SL.hpara$MLPdecay)
model_y   =  MySL(Data = data_train,             # training dataset
locY = 3,                         # response variable Y
locX = c(1,2),                # explanatory variable X1,X2
Ydist = gaussian(),               # Y is continuous
SL.list = SL.hpara$SLL,           # Machine learning algorithms
MTRY = SL.hpara$MTRY,
MLPL = SL.hpara$MLPL,
NMN = SL.hpara$NMN,
MLPdecay = SL.hpara$MLPdecay)
nuissance_X = function(X){
pi_1 = predict(model_a_z, data.frame(X,z=1))[[1]]
pi_0 = predict(model_a_z, data.frame(X,z=0))[[1]]
Ey_a1z1 = predict(model_y_za, data.frame(X,z=1,a=1))[[1]]
phi_0 = predict(model_y_za, data.frame(X,z=0,a=1))[[1]]
phi_1 = Ey_a1z1-phi_0
Ey_z1 = predict(model_y_z, data.frame(X,z=1))[[1]]
Ey_z0 = predict(model_y_z, data.frame(X,z=0))[[1]]
psi = (Ey_z1 - Ey_z0-phi_1)/(pi_1-pi_0)
return(data.frame(psi,phi_1,phi_0,pi_1,pi_0))
}
nuis = nuissance_X(data_pred[,1:2])
phi_1 = nuis$phi_1
phi_0 = nuis$phi_0
psi = nuis$psi
pi_1 = nuis$pi_1
pi_0 = nuis$pi_0
#for EIF
z = data_pred[[4]]
a = data_pred[[5]]
# model this later
pz_x = z*0.5 + (1-z)*0.5
pa_x = pi_1*pz_x + pi_0*(1-pz_x)
pa_zx = predict(model_a_z, data.frame(data_pred[,c(1:2,4)]))[[1]]
paz_x = a*pa_zx*pz_x + (1-a)*(1-pa_zx)*pz_x
y_L = predict(model_y, data.frame(data_pred[,1:2]))[[1]]
p_Y_0 = y_L - a*psi - z*phi_1
df_ = data.frame(pi_1,
pi_0,
phi_1,
phi_0,
psi,
p_Y_0,
pz_x,
pa_x,
paz_x)
return(cbind(data_pred,df_))
}
generated = single_gen_QIV(500)
0.75/2
data_input = generated[[1]]
att = generated[[2]]
s = rep(1:2,50)
data_input$s = s
z_ = data_input[s==2,]$z
a_ = data_input[s==2,]$a
nuisance_df = my_SL_QIV(data_train = data_input[s==1,],
data_pred = data_input[s==2,])
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
pa_x=nuisance_df$pa_x,
paz_x=nuisance_df$paz_x,
phi_1=nuisance_df$phi_1,
phi_0=nuisance_df$phi_0,
psi=nuisance_df$psi,
p_Y_0=nuisance_df$p_Y_0
)
eif_test[[1]]
mean(eif_test[[3]])
nuisance_df$paz_x
nuisance_df[,c("a","z","paz_x"))
nuisance_df[,c("a","z","paz_x")]
mean(nuisance_df[(nuisance_df$a==1)&(nuisance_df$z==1),c(paz_x)])
mean(nuisance_df[(nuisance_df$a==1)&(nuisance_df$z==1),paz_x])
mean(nuisance_df[(nuisance_df$a==1)&(nuisance_df$z==1),"paz_x"])
mean(nuisance_df[(nuisance_df$a==0)&(nuisance_df$z==0),"paz_x"])
mean(nuisance_df[(nuisance_df$a==0)&(nuisance_df$z==1),"paz_x"])
mean(nuisance_df[(nuisance_df$a==1)&(nuisance_df$z==0),"paz_x"])
summary(nuisance_df)
generated = single_gen_QIV(5000)
data_input = generated[[1]]
att = generated[[2]]
s = rep(1:2,50)
data_input$s = s
z_ = data_input[s==2,]$z
a_ = data_input[s==2,]$a
nuisance_df = my_SL_QIV(data_train = data_input[s==1,],
data_pred = data_input[s==2,])
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
mean(nuisance_df[(nuisance_df$a==1)&(nuisance_df$z==0),"paz_x"])
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
pa_x=nuisance_df$pa_x,
paz_x=nuisance_df$paz_x,
phi_1=nuisance_df$phi_1,
phi_0=nuisance_df$phi_0,
psi=nuisance_df$psi,
p_Y_0=nuisance_df$p_Y_0
)
eif_test[[1]]
mean(eif_test[[3]])
# psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
eif_f = function(psi_h){
return(nu_1*nu_2 - nu_3*nu_4 + (a/p_a)*(psi - psi_h))
}
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
# psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
eif_f = function(psi_h){
return(nu_1*nu_2 - nu_3*nu_4 + (a/p_a)*(psi - psi_h))
}
psi_hat = uniroot(f=eif_f,interval = c(-10000,10000))
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
pa_x=nuisance_df$pa_x,
paz_x=nuisance_df$paz_x,
phi_1=nuisance_df$phi_1,
phi_0=nuisance_df$phi_0,
psi=nuisance_df$psi,
p_Y_0=nuisance_df$p_Y_0
)
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
# psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
eif_f = function(psi_h){
return(nu_1*nu_2 - nu_3*nu_4 + (a/p_a)*(psi - psi_h))
}
psi_hat = uniroot(f=eif_f,interval = c(-10000,10000), tol = 0.0001)
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
pa_x=nuisance_df$pa_x,
paz_x=nuisance_df$paz_x,
phi_1=nuisance_df$phi_1,
phi_0=nuisance_df$phi_0,
psi=nuisance_df$psi,
p_Y_0=nuisance_df$p_Y_0
)
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
# psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
eif_f = function(psi_h){
return(mean(nu_1*nu_2 - nu_3*nu_4 + (a/p_a)*(psi - psi_h)))
}
psi_hat = uniroot(f=eif_f,interval = c(-10000,10000), tol = 0.0001)
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
pa_x=nuisance_df$pa_x,
paz_x=nuisance_df$paz_x,
phi_1=nuisance_df$phi_1,
phi_0=nuisance_df$phi_0,
psi=nuisance_df$psi,
p_Y_0=nuisance_df$p_Y_0
)
construct_psi_hat = function(y,a,z,pi_1,pi_0,pz_x,pa_x,paz_x,phi_1,phi_0,psi,p_Y_0){
#wald: E(psi|A=1)
# y = Outcome
# z = IV
# a = Treatment
# fz = P(Z=1)(L)
# faz = P(A=1,Z=1)(L)
# pi_1 = P(A=1|Z=1)(L)
# pi_0 = P(A=1|Z=0)(L)
# phi_1 = E(Y|A=1,Z=1) - E(Y|A=1,Z=0)(L)
# phi_0 = E(Y|A=1,Z=0)(L)
# psi = E([G(Y - phi_1) - (1-G)Y]/delta_a)(L)
# p_Y_0 = E(Y - Apsi - Gphi_1)(L)
# plugin = ATT
p_a = mean(a)
delta_a = pi_1-pi_0
nu_1 = pa_x/p_a*(2*z-1)/pz_x/delta_a
nu_2 = y - a*psi - z*phi_1 - p_Y_0
nu_3 = pa_x/p_a*a*(2*z-1)/paz_x/delta_a
nu_4 = y - z*phi_1 - phi_0
nu_6 = (a/p_a)*(psi)
# psi_hat = mean(nu_1*nu_2 - nu_3*nu_4 + nu_6)
eif_f = function(psi_h){
return(mean(nu_1*nu_2 - nu_3*nu_4 + (a/p_a)*(psi - psi_h)))
}
psi_hat = uniroot(f=eif_f,interval = c(-10000,10000), tol = 0.0001)$root
nu_5 = (a/p_a)*(psi-psi_hat)
eif = nu_1*nu_2 - nu_3*nu_4 + nu_5
var_psi_hat = mean((nu_1*nu_2 - nu_3*nu_4 + nu_5)^2)
return(list(psi_hat,var_psi_hat,eif))
}
eif_test = construct_psi_hat(y=nuisance_df$y,
a=nuisance_df$a,
z=nuisance_df$z,
pi_1=nuisance_df$pi_1,
pi_0=nuisance_df$pi_0,
pz_x=nuisance_df$pz_x,
